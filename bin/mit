#!/usr/bin/env ruby

require 'date'

VERSION = 'v0.1.0'.freeze

TODAY = ENV.key?('FIXED_DATE') ? Date.parse(ENV['FIXED_DATE']) : Date.today
MIT_DATE_REGEX = /\{(\d{4}\.\d{2}\.\d{2})\}/

class TodoFileParser
  TODOWithNumber = Struct.new(:line, :number)

  def initialize(todo_file_path)
    @todo_file_path = todo_file_path
  end

  def mits
    todo_lines = File.readlines(@todo_file_path)
    chomped_lines = todo_lines.map(&:chomp)

    all_todos = chomped_lines.map.with_index do |line, index|
      TODOWithNumber.new(line, index + 1)
    end

    not_completed_todos = all_todos.reject do |todo|
      todo.line.start_with?('x ')
    end

    not_completed_todos.
      select { |todo| todo.line.match(MIT_DATE_REGEX) }.
      map { |todo| MIT.new(todo.line, todo.number) }
  end
end

class MITListFormatter
  def initialize(mits)
    @mits = mits
  end

  def grouped_by_date
    output_lines = []

    if @mits.any?(&:past_due?)
      output_lines << 'Past due:'
      @mits.select(&:past_due?).each do |mit|
        output_lines << "  #{mit}"
      end
      output_lines << ''
    end

    mits_today_or_in_future = @mits.reject(&:past_due?).group_by(&:date)
    sorted_dates = mits_today_or_in_future.keys.sort

    sorted_dates.each do |date|
      mits_for_date = mits_today_or_in_future[date]

      output_lines << DateFormatter.new(date).format
      mits_for_date.each do |mit|
        output_lines << "  #{mit}"
      end
      output_lines << ''
    end

    output_lines.join("\n")
  end
end

class DateFormatter
  def initialize(date)
    @date = date
  end

  def format
    raise(StandardError, 'Cannot format date prior to today') if @date < TODAY

    case
    when today?
      'Today:'
    when tomorrow?
      "Tomorrow, #{weekday}:"
    when within_seven_days?
      "#{weekday}:"
    when next_week?
      "#{weekday}, next week, #{@date}:"
    else
      "#{weekday}, #{number_of_weeks_from_now} weeks from now, #{@date}:"
    end
  end

  def today?
    @date == TODAY
  end

  def tomorrow?
    @date == TODAY + 1
  end

  def within_seven_days?
    @date <= TODAY + 7
  end

  def next_week?
    @date.cweek == (TODAY + 7).cweek
  end

  def number_of_weeks_from_now
    # To account for potential transitions between years when counting weeks
    # into the future, step forward week by week and check if the date of the
    # first day that week matches.
    #
    # As the case-statement above has already handled the "next week"-case,
    # start from two weeks into the future.
    two_weeks = 14
    days_in_week = 7

    days_away_from_matching_week =
      (two_weeks..Float::INFINITY).
      step(days_in_week).
      find do |days_into_future|
        future = TODAY + days_into_future.to_i

        start_of_week_for_date = @date - @date.cwday
        start_of_week_in_future = future - future.cwday

        start_of_week_for_date == start_of_week_in_future
      end.to_i

    days_away_from_matching_week / days_in_week
  end

  def weekday
    Date::DAYNAMES[@date.wday]
  end
end

class MIT
  def initialize(todo, number)
    @todo = todo
    @number = number
  end

  def date
    @date ||= Date.parse(@todo.match(MIT_DATE_REGEX)[1])
  end

  def to_s
    @to_s ||= "#{priority_token}#{task} #{number}"
  end

  def past_due?
    date < TODAY
  end

  private

  def task
    @todo.split(MIT_DATE_REGEX).last.strip
  end

  def priority_token
    if p = @todo.match(/\A\([A-Z]\) /) then p[0] else nil end
  end

  def number
    "(#{@number})"
  end
end

class CLI
  def run
    case
    when usage_requested_from_todo_help?
      $stdout.puts usage_message
      exit 0
    when usage_requested?
      $stdout.puts usage_message
      exit 0
    when version_requested?
      $stdout.puts version_message
      exit 0
    when no_action_arguments?
      $stdout.puts all_mits_listing
      exit 0
    end
  end

  private

  def usage_requested_from_todo_help?
    # Normally the add-on will be invoked as a subcommand (like
    # `todo.sh mit foo`), meaning that the actual mit-action, along with its
    # various arguments, will be placed in ARGV[1] and higher.
    #
    # The only exception to this case is when the add-on is invoked through
    # `todo.sh help`. This command will iterate through all available add-ons
    # and invoke them like `mit usage`, meaning that the action will be present
    # in ARGV[0].

    ARGV[0] == 'usage'
  end

  def usage_requested?
    ARGV[1] == 'usage' ||
      ARGV[1] == '-h' ||
      ARGV[1] == '--help'
  end

  def version_requested?
    ARGV[1] == '-v' ||
      ARGV[1] == '--version'
  end

  def no_action_arguments?
    ARGV[2].nil?
  end

  def usage_message
    usage_message = <<-EOF
      Most Important Tasks (MIT):
        Displays Most Important Tasks (MIT) in todo.txt file, or adds new ones.

        mit [-h|--help|-v|--version]

        -h, --help      Displays help message.
        -v, --version   Displays version information.

        mit
          List all MITs with default formatting.
    EOF

    # Remove leading indentation
    usage_message.gsub(/^#{usage_message.scan(/^[ \t]*(?=\S)/).min}/, '')
  end

  def version_message
    "mit (ruby) #{VERSION}"
  end

  def all_mits_listing
    mits = TodoFileParser.new(ENV['TODO_FILE']).mits

    if mits.empty?
      'No MITs found.'
    else
      MITListFormatter.new(mits).grouped_by_date
    end
  end
end

CLI.new.run
